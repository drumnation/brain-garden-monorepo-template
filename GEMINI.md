# Gemini Instructions - Monorepo Root

This file is auto-generated from `.cursor/rules-source-builder/`.

**DO NOT EDIT THIS FILE DIRECTLY.** Edit source files and run `pnpm rules:build`.

---

## Rule

**Description:** Documentation strategy and hierarchy for the monorepo

**File Patterns:** docs/**/*, **/README.md, **/CHANGELOG.md

**Content:**

# Monorepo Documentation Strategy

<!-- ==================== METADATA ==================== -->
ruleType: always
description: >
  Comprehensive documentation strategy for monorepo projects covering location, format,
  maintenance, and cross-referencing standards.
whenToUse:
  - Creating new documentation
  - Updating existing documentation
  - After completing any feature or refactor
  - When adding new packages or apps to the monorepo
# =====================================================

## üìÇ Documentation Location Hierarchy

The monorepo uses a hierarchical documentation approach to ensure domain knowledge is stored at the appropriate scope level.

### 1. Package/App-Level Documentation
- **Primary Location:** Inside each package or app in a `docs/` subfolder
  ```
  packages/ui/docs/            # UI package-specific docs
  apps/web/docs/               # Web app-specific docs
  ```
- **Purpose:** Package-specific implementation details, API usage, internal patterns

### 2. Feature-Level Documentation
- **Location:** `/docs/features/[feature-name]/`
- **Purpose:** Documentation for features that span multiple packages

### 3. Global Documentation
- **Location:**
  ```
  /docs/architecture/          # System-wide architecture
  /docs/concepts/              # Shared concepts and patterns
  /docs/architecture/adr/      # Architecture Decision Records
  ```
- **Purpose:** Project-wide knowledge and design decisions

### Documentation Placement Decision Matrix

| Documentation Type | Placement Location |
|--------------------|-------------------|
| Feature spanning multiple packages | `/docs/features/[feature-name]/` |
| Implementation in shared workspace package | `packages/[pkg]/docs/` |
| Package-level setup or design notes | `packages/[pkg]/README.md` or `packages/[pkg]/docs/` |
| App-specific implementation details | `apps/[app]/docs/` (if present) or `/docs/apps/[app]/` |
| Architectural decisions | `/docs/architecture/adr/` |

## üìÑ Documentation Creation Standards

### File Naming
Use kebab-case filenames that reflect the topic clearly:
- `auth-token-refresh-flow.md`
- `data-fetching-patterns.md`
- `button-component-api.md`

### YAML Frontmatter (Required)

All documentation files must include YAML frontmatter with the following fields:

```yaml
---
title: "API Caching Pattern"
description: "Explains the custom caching strategy used in `@api` for SSR and client hydration."
keywords:
  - api
  - caching
  - SWR
  - react-query
  - ssr
  - hydration
related_features: ["dashboard-data-pipeline"]
related_concepts: ["react-query-vs-swr"]
related_adr: ["001-cache-layer-decision"]
last_updated: "YYYY-MM-DD"  # Always use ISO 8601 format
---
```

### Document Structure

1. **Introduction** (immediately after frontmatter)
   - 2-4 sentence summary of the document's purpose
   - Provides context for search and RAG indexing

2. **Content Sections**
   - Use clear H2/H3 headers with relevant keywords
   - Short, atomic sections are preferred over long narratives
   - Include code examples where appropriate
   - Use tables for comparisons or options

3. **Cross-References**
   - Link to related documentation as appropriate
   - Use standardized cross-linking (see section below)

4. **Conclusion**
   - Summary of key points
   - Next steps or related topics to explore

## üîÑ Documentation Maintenance

### Index File Updates

Update relevant `.index.md` files when creating or modifying documentation:

- `docs/features/features.index.md`
- `docs/concepts/concepts.index.md`
- `docs/architecture/adr.index.md`
- `docs/packages/[pkg]/[pkg].index.md` (if applicable)

For each document, add an entry with format:
```markdown
- [[Document Title]](./document-filename.md): Brief description.
```

### Avoiding Duplication

Before creating new documentation:
1. Check index files for similar topics
2. Search for existing documentation with similar keywords
3. If similar documentation exists, consider updating or expanding it instead

### Documentation Review

After significant changes:
1. Update the `last_updated` field in the frontmatter
2. Verify that all cross-links still work
3. Check that examples remain current
4. Ensure all index files are updated

## üîó Cross-Linking Standards

### Relative Path Links
Use relative paths when linking between documents in the same package or nearby:
```markdown
[Authentication Flow](mdc:../../shared/docs/auth-flow.md)
```

### Agent-Readable References
Use @ notation when referencing documentation for agent processing:
```markdown
@docs/packages/ui/index.md
```

### External Links
For external resources, include the full URL and consider adding a timestamp:
```markdown
[React Query Documentation](mdc:https:/tanstack.com/query/latest) (as of 2025-04)
```

## üìö Documentation Types

### README.md Files
- **Purpose:** Quick start, installation, primary usage examples
- **Location:** Root of each package, app, and the monorepo

### API Documentation
- **Purpose:** Detailed interface specifications, usage guidelines
- **Location:** `packages/[pkg]/docs/api/`

### Architecture Decision Records (ADRs)
- **Purpose:** Document significant architectural decisions
- **Location:** `/docs/architecture/adr/`
- **Format:** Follow standard ADR template with:
  - Title and date
  - Status (proposed, accepted, superseded)
  - Context
  - Decision
  - Consequences

### Guides and Tutorials
- **Purpose:** Step-by-step instructions for common tasks
- **Location:** `packages/[pkg]/docs/guides/` or `/docs/guides/`

## üîç Documentation Lookup Priority

When searching for relevant documentation:

1. **First,** look for `docs/` within the current package or app
2. **Then,** check shared or global documentation areas
3. **Use** `.index.md` files to guide lookup
4. **Never** assume knowledge lives only in root-level documentation

## ‚úÖ Documentation Completeness Checklist

- [ ] Appropriate location based on scope
- [ ] Complete YAML frontmatter
- [ ] Clear introduction and purpose statement
- [ ] Well-structured content with descriptive headings
- [ ] Code examples (if applicable)
- [ ] Cross-links to related documentation
- [ ] Updated index files
- [ ] Last updated timestamp is current

---

## Rule

**Description:** Electron + Express.js hexagonal architecture with functional DI patterns and modular structure

**File Patterns:** apps/\*\*/\*, packages/\*\*/\*

**Content:**

# **Cursor Agent Rule: Modular Core/Adapter Monorepo Architecture**

**Objective:** Maintain a highly modular, decoupled, and testable TypeScript monorepo. All platform-agnostic business logic ("Core") **must** be extracted into `packages/*`. All platform-specific entry points ("Adapters," e.g., `apps/api-server`, `apps/electron-main`) **must** be thin wrappers that consume the Core.

**Core Principle:** This architecture is a form of  Hexagonal (Ports & Adapters) Architecture.

* **The "Core" (`packages/core-*`):** This is your application's "engine." It contains all business logic, services, repositories, and domain types. It has **zero knowledge** of the outside world (i.e., no imports from `express` or `electron`).
* **The "Adapters" (`apps/*`):** These are the "delivery mechanisms." They are thin wrappers that translate platform-specific I/O (HTTP requests, Electron IPC calls) into method calls on the Core. They are responsible for DI, composition, and error translation.

## **1. Monorepo & Project Structure**

* **Layout:** Use pnpm workspaces.

    ```txt
    / (root)
    ‚îú‚îÄ package.json        # defines workspaces: ["apps/*", "packages/*"]
    ‚îú‚îÄ pnpm-workspace.yaml
    ‚îú‚îÄ tsconfig.base.json  # Base TS config with path aliases
    ‚îú‚îÄ apps/
    ‚îÇ   ‚îú‚îÄ api-server/     # Express API Adapter
    ‚îÇ   ‚îú‚îÄ electron-main/  # Electron Main Process Adapter
    ‚îÇ   ‚îî‚îÄ renderer/       # Electron Frontend (Client) Adapter
    ‚îÇ
    ‚îî‚îÄ packages/
        ‚îú‚îÄ core-feature-users/ # Core: "Users" Bounded Context
        ‚îú‚îÄ core-feature-posts/ # Core: "Posts" BoundedContext
        ‚îú‚îÄ core-db/            # Core: Shared DB client/schema
        ‚îú‚îÄ electron-preload/   # Adapter: Electron preload script
        ‚îî‚îÄ ipc-contract/       # Adapter: Shared types for Electron IPC
    ```

* **Package Decision:**
  * If code is platform-agnostic (business logic, data access, utilities), it **must** go in a `packages/core-*` library.
  * If code is platform-specific (HTTP routes, IPC handlers, window management), it **must** go in an `apps/*` application.

### **2. `packages/core-*` Rules (The "Core" Engine)**

* **File Naming:** Strictly use `<feature>.<role>.ts`.

* **Role Suffixes:**

  * `service.ts`: Core business logic, orchestration.
  * `repo.ts`: Abstract data persistence (database queries, `fs` access).
  * `schema.ts`: Validation schemas (Zod) for data shapes.
  * `types.ts`: TypeScript interfaces/types for the domain.
  * `util.ts`: Pure, domain-specific helper functions.
  * `test.ts`: Unit/integration tests for the corresponding files.

* **Firewall Rule:** Files within `packages/core-*` **must not** import from any file in `apps/*`. They also **must not** import `express`, `electron`, or any other platform-specific library.

* **Dependency Injection:** All services and repos **must** be *pure factory functions* that receive their dependencies.

    ```ts
    // packages/core-db/src/db.client.ts
    // This is the *only* place a concrete db client is defined.
    export const makeDbClient = (config: { connectionString: string }) => ({
      // ... returns a client (e.g., PrismaClient, node-postgres Pool)
    });

    // packages/core-feature-users/src/user.repo.ts
    export const makeUserRepo = (deps: { db: DbClient }) => ({
      list: () => deps.db.query<User[]>('SELECT * FROM users'),
    });

    // packages/core-feature-users/src/user.service.ts
    export const makeUserService = (deps: {
      userRepo: ReturnType<typeof makeUserRepo>;
    }) => ({
      getAllUsers: async () => {
        // ... business logic
        return deps.userRepo.list();
      },
    });
    ```

### **3. `apps/*` Rules (The "Adapters")**

* **Core Principle:** All `apps/*` are **Composition Roots**. Their `main.ts` is responsible for:
    1. Creating concrete dependencies (e.g., `makeDbClient` with a platform-specific path/URL).
    2. Assembling the *entire* dependency graph by calling the `make...` factories from `packages/core-*`.
    3. Injecting the final, wired-up services into its own platform-specific "controllers."
* **No Business Logic:** Adapters **must not** contain any business logic. Their "controllers" are thin "Translator" layers.

#### **3.1 `apps/api-server` (Express Adapter)**

* **Structure:**
    `apps/api-server/src/`
    `‚îú‚îÄ modules/<feature>/<feature>.controller.ts`
    `‚îú‚îÄ infra/http/`
    `‚îÇ   ‚îú‚îÄ server.ts`
    `‚îÇ   ‚îî‚îÄ routes.ts`
    `‚îî‚îÄ main.ts` (Composition Root)
* **Controller (`<feature>.controller.ts`):** This is a "Translator" from HTTP to the Core Service. It **must not** contain business logic.

    ```ts
    // Translates (req, res) to a service call
    export const makeGetUsersHttp =
      (userService: ReturnType<typeof makeUserService>) =>
      async (_req, res, next) => {
        try {
          const users = await userService.getAllUsers();
          return res.json(users);
        } catch (e) {
          return next(e); // Pass to error middleware
        }
      };
    ```

#### **3.2 `apps/electron-main` (Electron Adapter)**

* **Structure:**
    `apps/electron-main/src/`
    `‚îú‚îÄ modules/<feature>/<feature>.controller.ts`
    `‚îú‚îÄ infra/electron/`
    `‚îÇ   ‚îú‚îÄ ipc.ts`
    `‚îÇ   ‚îî‚îÄ windows.ts`
    `‚îî‚îÄ main.ts` (Composition Root)
* **Controller (`<feature>.controller.ts`):** This is a "Translator" from IPC to the *exact same* Core Service. It **must not** contain business logic.

    ```ts
    // Translates (event, args) to a service call
    export const makeGetUsersIpc =
      (userService: ReturnType<typeof makeUserService>) =>
      async (_event: IpcMainInvokeEvent) => {
        // NOTE: No try/catch needed if using the error wrapper (Section 5)
        const users = await userService.getAllUsers();
        return users;
      };
    ```

#### **3.3 `packages/electron-preload` (Secure Bridge Adapter)**

* Its sole purpose is to be the `contextBridge` API. It defines the API contract for the `renderer`.

    ```ts
    // packages/electron-preload/src/index.ts
    import { contextBridge, ipcRenderer } from 'electron';
    import { IpcContract } from '@pkg/ipc-contract'; // Shared types

    const api: IpcContract = {
      getUsers: () => ipcRenderer.invoke('users:get'),
    };

    contextBridge.exposeInMainWorld('electronAPI', api);
    ```

### **4. Size & Complexity Limits (Enforced via Linting)**

* **Max File Length:** 500 lines (`eslint: max-lines-per-file`).
* **Max Function Length:** 75 lines (`eslint: max-lines-per-function`).
* **Cyclomatic Complexity:** ‚â§ 10 (`eslint: complexity`).
* **Nesting Depth:** ‚â§ 4 (`eslint: max-depth`).
* **Action:** If limits are exceeded, refactor immediately by extracting logic into smaller, focused functions.

### **5. Error Handling**

* **Core (`packages/core-*`):** Services/Repos **should** throw custom, structured errors (e.g., `NotFoundError`, `ValidationError`) defined in a shared utility.
* **Adapters (`apps/*`):** Adapters **must** catch these errors and translate them into platform-specific responses.
  * **`apps/api-server`:** Use a single, global error handling middleware in `infra/http/server.ts` that catches errors, logs them, and sends a standardized JSON error response (e.g., `res.status(404).json({ message: 'Not Found' })`).
  * **`apps/electron-main`:** Use a shared `handleIpc` wrapper in `infra/electron/ipc.ts` that wraps *every* registered handler.

      ```ts
        // infra/electron/ipc.ts
        export const handleIpc = (handler) => async (event, ...args) => {
          try {
            const data = await handler(event, ...args);
            return { ok: true, data };
          } catch (error) {
            log.error('IPC Error:', error); // Structured logging
            return {
              ok: false,
              error: { message: error.message, name: error.name },
            };
          }
        };

        // ...in your ipc registration
        ipcMain.handle(
          'users:get',
          handleIpc(wiredControllers.userController.getUsersHandler),
        );
        ```

### **6. Path Aliases & Imports**

* Use `tsconfig.base.json` to define shared path aliases. This is mandatory.

    ```json
    {
      "compilerOptions": {
        "baseUrl": ".",
        "paths": {
          "@app/api-server/*": ["apps/api-server/src/*"],
          "@app/electron-main/*": ["apps/electron-main/src/*"],
          "@pkg/core-users/*": ["packages/core-feature-users/src/*"],
          "@pkg/core-db/*": ["packages/core-db/src/*"],
          "@pkg/ipc-contract": ["packages/ipc-contract/src/index.ts"]
        }
      }
    }
    ```

* **Rule:** `packages/*` **must never** use an `@app/*` alias.

### **7. Workflow: TDD for Core Logic & Adapters**

This workflow is **mandatory** for new features to ensure decoupling.

**Goal:** Implement a new feature, `getPostById(id)`.

* **Step 1: Define the Contract.**

  * In `packages/core-feature-posts/src/post.types.ts`, define the `Post` type.
  * In `packages/ipc-contract/src/index.ts`, add `getPost: (id: string) => Promise<{ ok: true, data: Post } | { ok: false, error: any }>` to the contract.

* **Step 2: Write Failing Adapter Tests (The "Outside-In").**

  * **Test 1 (Express):** In `apps/api-server`, write an integration test using `supertest`.

      ```ts
        it('should return 404 for a missing post', async () => {
          // Wire up a test server with a *mock* postService
          const mockService = { getPostById: async ()_ => { throw new NotFoundError(); } };
          const app = createTestServer({ postService: mockService });
          await request(app).get('/api/posts/123').expect(404);
        });
        ```

  * **Test 2 (Electron):** In `apps/electron-main`, write a unit test for the controller.

      ```ts
        it('should return a not-found error object', async () => {
          // Wire up the controller with a *mock* postService
          const mockService = { getPostById: async ()_ => { throw new NotFoundError(); } };
          const controller = makeGetPostIpc(mockService);
          const result = await handleIpc(controller)(null, '123'); // Call wrapped handler
          expect(result.ok).toBe(false);
          expect(result.error.name).toBe('NotFoundError');
        });
        ```

* **Step 3: Write Failing Core Logic Test (The "Inside").**

  * In `packages/core-feature-posts/src/post.service.test.ts`:

      ```ts
        it('should throw NotFoundError if repo returns null', async () => {
          const mockRepo = { getById: async () => null };
          const service = makePostService({ postRepo: mockRepo });
          await expect(service.getPostById('123')).rejects.toThrow(NotFoundError);
        });
        ```

* **Step 4: Implement the Core Logic.**

  * Write the code in `post.service.ts` and `post.repo.ts` until the test in **Step 3** passes.

* **Step 5: Pass the Adapter Tests.**

  * Implement the thin controllers in `api-server` and `electron-main`.
  * Wire the *real* `makePostService` (from **Step 4**) into the DI container for both `api-server` and `electron-main`.
  * The tests from **Step 2** should now pass, proving the *entire* stack works for *both* platforms.

### **8. Duplication & Orphan Prevention**

* **DRY Principle:** Before writing new code, **always** search `packages/core-*` for existing logic.
* **CI Checks:**
  * `depcheck`: Fail build on unused dependencies.
  * `eslint-plugin-unused-imports`: Fail build on unused imports.
  * `pnpm list -r --depth -1`: (In CI script) Check for unexpected cross-dependencies (e.g., a `core` package depending on an `app`).

### **9. Code Generation & Scaffolding**

* **Mandatory Scaffolding:** Use a scaffolding tool (e.g., Plop.js, Hygen) to generate new `core-feature-*` packages or new modules within adapters.
* **Templates:** The templates **must** create the standard file structure (`<feature>.service.ts`, `<feature>.repo.ts`, `<feature>.service.test.ts`, etc.) and their corresponding test files.
* **PR Enforcement:** Pull requests adding new features manually (without using the generator) **should** be rejected.

---

## Rule

**Description:** Core monorepo structure, ESM-only, no-build libraries, shared config, agent coordination

**File Patterns:** **/*

**Content:**

# Monorepo Structure and Configuration (v4)

## ‚ö†Ô∏è CRITICAL STRUCTURAL UNDERSTANDING

This document contains ESSENTIAL information about how the monorepo is structured and the development philosophy behind it. It must be understood for ALL operations in the codebase.

### Core Principles

1.  **ESM-Only:** We exclusively use ES Modules. CommonJS (`require`, `module.exports`) is not used. This simplifies our tooling and aligns with the modern JavaScript ecosystem.
2.  **No Build Step for Libraries:** Packages in `/packages` are not "built" into a `dist` folder. We export TypeScript source files (`.ts`, `.tsx`) directly. A runtime transpiler (like `tsx`) handles this for us, enabling instantaneous hot-reloading and simpler debugging.
3.  **Configuration is SHARED:** All tooling configuration (ESLint, Prettier, TypeScript, Testing) is centralized in the `/tooling` directory and consumed by all other workspaces. **DO NOT** create duplicate or one-off configurations.
4.  **Strict Naming & Structure:** Packages and folder structures follow a strict, predictable pattern. **DO NOT** deviate from it.
5.  **Agent Coordination First:** Before running any command, always check the `_errors/` and `_logs/` directories managed by `@kit/brain-monitor` to prevent redundant work.

### Devil's Advocate: Why No CommonJS?

You're right to want to keep things simple with ESM-only. But for the sake of completeness, here's the trade-off:

  * **Pros (Our Approach):** Massively simplified build process (or lack thereof), single module system to reason about, aligns with web standards, and enables cleaner, more modern syntax like top-level `await`.
  * **Cons:** Dropping CJS means older Node.js environments or tools that *only* support `require()` cannot consume our packages natively. Since we control the entire stack within this monorepo and all our applications are ESM-compatible, this is a trade-off we gladly accept for the significant boost in developer experience and simplicity.

-----

## üìÇ Monorepo Layout

```txt
/apps¬† ¬† ¬† ¬† ¬† Executable applications (e.g., servers, web frontends)
/packages¬† ¬† ¬† Shared libraries consumed by apps or other packages
/tooling¬† ¬† ¬† ¬† Shared tooling and configuration (`@kit/*`)
/_errors¬† ¬† ¬† ¬† Real-time validation failure reports (via @kit/brain-monitor)
/_logs¬† ¬† ¬† ¬† ¬† Real-time server logs (via @kit/brain-monitor)
```

### üè∑ Naming Patterns

Packages must be scoped to align with their location and purpose.

```txt
/apps¬† ¬† ¬† ¬† ¬† @[app-name]
/packages¬† ¬† ¬† @[app-name]/[package-name]
/tooling¬† ¬† ¬† ¬†@kit/*
```

-----

## üì¶ Package Configuration (The "No Build" Way)

This is the most critical change from `v3`. Library packages in `/packages` **do not have a build step**.

### `package.json` Template for a Library

This is the standard template for any new or converted library in `/packages`.

```json
{
  "name": "@[app-name]/[package-name]",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "exports": {
    // Points directly to the TypeScript source file
    ".": "./src/index.ts",
    // Allows importing sub-modules directly
    "./*": "./src/*.ts"
  },
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "files": [
    "src"
  ],
  "scripts": {
    "clean": "rimraf node_modules .turbo",
    "format": "prettier --check \"**/*.{ts,tsx,md}\"",
    "lint": "eslint . --ext .ts,.tsx",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@kit/env-loader": "workspace:*"
  },
  "devDependencies": {
    "@kit/eslint-config": "workspace:*",
    "@kit/prettier-config": "workspace:*",
    "@kit/testing": "workspace:*",
    "@kit/tsconfig": "workspace:*"
  },
  "eslintConfig": {
    "root": true,
    "extends": [
      "@kit/eslint-config/base"
    ]
  },
  "prettier": "@kit/prettier-config"
}
```

### `tsconfig.json` for a Library

Note the absence of `"outDir"` and `"declaration"`. We are not compiling to a separate directory.

```json
{
  "extends": "@kit/tsconfig/node", // or "@kit/tsconfig/react"
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

-----

## üöÄ Root `package.json` & Turbo Pipeline

The root `package.json` contains scripts that run across the entire monorepo using Turborepo. The `turbo.json` file configures the dependency graph and caching for these tasks.

### Root `package.json`

```json
{
  "name": "your-monorepo-name",
  "private": true,
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "clean": "turbo run clean",
    "format": "turbo run format",
    "lint": "turbo run lint",
    "typecheck": "turbo run typecheck",

    "test": "turbo run test",
    "test:watch": "turbo run test:watch",
    "test:unit": "turbo run test:unit",
    "test:integration": "turbo run test:integration",
    "test:e2e": "turbo run test:e2e",
    "test:storybook": "turbo run test:storybook",
    "test:e2e:browser": "turbo run test:e2e:browser",

    "brain:validate": "turbo run validate",
    "brain:logs": "pnpm --filter=@kit/brain-monitor run logs",
    "brain:typecheck-failures": "pnpm --filter=@kit/brain-monitor run typecheck-failures",
    "brain:test-failures": "pnpm --filter=@kit/brain-monitor run test-failures",
    "brain:lint-failures": "pnpm --filter=@kit/brain-monitor run lint-failures",
    "brain:format-failures": "pnpm --filter=@kit/brain-monitor run format-failures"
  },
  "devDependencies": {
    "turbo": "latest",
    "tsx": "latest",
    "typescript": "latest"
  },
  "packageManager": "pnpm@9.x.x"
}
```

### Root `turbo.json`

This pipeline is configured for our "no-build" library strategy and includes the agentic validation tasks.

```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {
      "cache": true
    },
    "typecheck": {
      "cache": true
    },
    "test": {
      "dependsOn": ["^build"],
      "cache": true
    },
    "test:watch": {
      "cache": false,
      "persistent": true
    },
    "validate": {
      "dependsOn": ["lint", "typecheck", "test"],
      "cache": true
    },
    "clean": {
      "cache": false
    }
  }
}
```

  * **`build`**: Only applies to `apps`. `dist/**` and `.next/**` are specified as outputs for caching. Libraries have no `build` script, so Turbo ignores them for this task.
  * **`dev` / `test:watch`**: Marked as non-cacheable and persistent for long-running processes.
  * **`lint` / `typecheck` / `test`**: These tasks are fully cacheable. If the source files haven't changed, the results are pulled from the cache instantly.
  * **`validate`**: This is the master task for `@kit/brain-monitor`. It depends on all other validation tasks completing first.

-----

## üß™ Unified Testing ‚Äì `@kit/testing`

The `@kit/testing` package provides a unified, modern, and highly modular testing framework for the entire monorepo. It uses a lazy-loaded API to improve performance.

### Available Configurations & Modern API

Instead of importing a static config object, you now call an async function that returns a configuration. This is faster and more flexible.

| Legacy Export (v3)                | Modern API (v4)                               | Purpose                               |
| --------------------------------- | --------------------------------------------- | ------------------------------------- |
| `unitConfig`                      | `await configs.vitest.unit()`                 | Unit tests (Vitest + JSDOM)           |
| `integrationConfig`               | `await configs.vitest.integration()`          | Integration tests (Vitest + Node)     |
| `e2eConfig`                       | `await configs.vitest.e2e()`                  | Backend/API E2E tests (Vitest)        |
| `storybookConfig`                 | `await configs.vitest.storybook()`            | Storybook component tests (Vitest)    |
| `playwrightConfig`                | `await configs.playwright.browser()`          | Browser E2E tests (Playwright)        |
| `playwrightBackendConfig`         | `await configs.playwright.api()`              | Backend/API tests (Playwright)        |
| `storybookE2EConfig`              | `await configs.playwright.storybook()`        | Storybook E2E tests (Playwright)      |
| `testRunnerConfig`                | `await configs.storybook.testRunner()`        | For `@storybook/test-runner`          |

### Example `vitest.config.ts` (Modern API)

```typescript
// vitest.config.ts
import { mergeConfig } from 'vitest/config';
import { configs, presets } from '@kit/testing';

// Load the base configuration asynchronously
const baseConfig = await configs.vitest.unit();

// Merge with custom overrides using presets
export default mergeConfig(baseConfig, {
  test: {
    // Use a stricter coverage preset
    coverage: presets.coverage.strict,
    // Use a longer timeout preset
    ...presets.timeouts.medium,
  }
});
```

For the full API, migration steps, and available presets, see the detailed README in `tooling/testing/README.md`.

-----

## üß† Agent Coordination ‚Äì `@kit/brain-monitor`

To prevent multiple AI agents from performing the same time-consuming tasks (like running tests or type-checking) and to provide a centralized place for debugging, we use `@kit/brain-monitor`.

**MANDATORY BEHAVIOR:** Before running any validation or server command, **ALWAYS check the `_errors/` and `_logs/` directories first.**

### Workflow

1.  **Check for Existing Errors:**

    ```bash
    # See if type-checking has already failed
    cat _errors/errors.typecheck-failures.md

    # See if any tests are failing
    cat _errors/errors.test-failures.md
    ```

2.  **Run Validation (Only if Needed):** If the reports are stale or empty, run the validation.

    ```bash
    # Run all validations and generate reports
    pnpm brain:validate

    # Or run just one
    pnpm brain:test-failures
    ```

3.  **Debug Servers:** Check logs before restarting a server.

    ```bash
    # Watch the API server log in real-time
    tail -f _logs/financial-api.log

    # Or start all dev servers with logging enabled
    pnpm dev
    ```

This workflow saves time and compute resources, and provides a clear task list for fixing issues. For full CLI details, see the README in `tooling/brain-monitor/README.md`.

-----

## üîë Environment Variables ‚Äì `@kit/env-loader`

The `@kit/env-loader` package provides a standardized way to load and access environment variables across all applications and packages.

### Installation & Setup

It should be added as a dependency to any package that needs access to environment variables.

```bash
pnpm add @kit/env-loader
```

### Loading Order

The loader searches for `.env` files in a hierarchical order, with earlier locations taking precedence:

1.  **`monorepo-root/.env`**: Global variables shared across all apps.
2.  **`apps/my-app/.env`**: Local variables that override the global ones for a specific app.
3.  `process.env`: System-level environment variables (highest priority).

### Usage Example (Node.js Backend)

At the entry point of your application (`server.ts`, `index.ts`), load the environment.

```typescript
// In apps/backend/src/server.ts
import { loadEnvironment, requireEnv, getIntEnv } from '@kit/env-loader/node';

const result = loadEnvironment({
  appName: 'backend-api',
  required: ['DATABASE_URL', 'API_KEY']
});

if (!result.success) {
  console.error('FATAL: Missing required environment variables:', result.missingRequired);
  process.exit(1);
}

const PORT = getIntEnv('PORT', 8080);
const API_KEY = requireEnv('API_KEY'); // Throws an error if not found
```

### Usage Example (Browser Frontend)

In browser-based apps (e.g., Vite/React), the bundler exposes the variables. You only need the helper functions. **Remember to prefix public variables** (e.g., `VITE_`).

```typescript
// In apps/frontend/src/api/client.ts
import { getEnv, requireEnv } from '@kit/env-loader/browser';

const API_URL = getEnv('VITE_API_URL', 'http://localhost:8080');
const PUBLIC_KEY = requireEnv('VITE_STRIPE_PUBLIC_KEY');
```

This package does not require any `turbo.json` configuration as it runs at runtime within your application code. For more details, see `tooling/env-loader/README.md`.

---

## üîó Related Rules

### Backend Development Patterns

**For Express.js Applications:**
See `monorepo-node-express-architecture.rules.mdc` for:
- HTTP API server architecture
- File naming: `<feature>.<role>.ts`
- Routes, controllers, middleware patterns
- Express-specific DI with Effect/fp-ts

**For Scripts, CLIs, and Standalone Programs:**
See `node.functional-isolated-concerns.rules.mdc` for:
- Functional programming patterns (no classes)
- File organization: `feature/<name>.<purpose>.ts`
- Background workers and batch processors
- Pure functions and isolated concerns

**Decision Guide:**
- Building HTTP API? ‚Üí Use Express Architecture
- Building script/CLI/worker? ‚Üí Use Functional Isolated Concerns
- Both in same app? ‚Üí Express for HTTP layer, Functional for utilities

---

## Rule

**Description:** Test-Driven Development workflow for PM Agent with Brain Garden integration

**File Patterns:** **/*.test.ts, **/*.spec.ts, **/*.test.tsx, packages/core-*/**/*

**Content:**

# PM Agent TDD Workflow

## üéØ Core Principle

**PM Agent solves the motivation crisis in AI-assisted development.**

Therefore, **E2E and Integration tests are MOST IMPORTANT** because they:
- ‚úÖ Prove features actually work (AI-detectable signals)
- ‚úÖ Prevent regressions when AI makes changes
- ‚úÖ Validate the entire motivation system end-to-end
- ‚úÖ Give confidence that "motivation metrics" are accurate

**Unit tests are supplementary** - they test isolated logic but don't prove the feature delivers value.

---

## üìê Test Hierarchy (Priority Order)

### 1. **E2E Tests** (Highest Priority)
**Purpose:** Prove entire user workflows work in Electron app

**Test these flows:**
```typescript
// E2E: Motivation Dashboard displays correct metrics
describe('Motivation Dashboard E2E', () => {
  it('should display project quality score from database', async () => {
    // 1. Setup: Insert test project with quality_score = 94
    // 2. Launch Electron app
    // 3. Navigate to project
    // 4. Assert: Quality score 94/100 is visible
    // 5. Assert: Motivation message "ABSOLUTELY WORTH RESUMING" appears
  });

  it('should refresh metrics when project is rescanned', async () => {
    // Test that scanning updates UI in real-time
  });
});
```

**Tools:**
- Playwright for Electron
- Real SQLite database (test fixtures)
- Full Electron main + renderer interaction

### 2. **Integration Tests** (High Priority)
**Purpose:** Prove adapters ‚Üí Core ‚Üí Database flows work

**Test these integrations:**
```typescript
// Integration: Quality checker correctly calculates scores
describe('Quality Checker Integration', () => {
  it('should calculate correct quality score for project', async () => {
    const projectPath = '/test/fixtures/cannabis-codex';
    const qualityChecker = makeQualityChecker({ db, fs });

    const score = await qualityChecker.calculateScore(projectPath);

    expect(score).toBeGreaterThan(80);
    expect(score.metrics.testCoverage).toBe(82);
    expect(score.metrics.hasBrainGarden).toBe(true);
  });
});

// Integration: Express API returns project data correctly
describe('Express API Integration', () => {
  it('GET /api/projects/:id should return full project with metrics', async () => {
    const response = await request(app).get('/api/projects/1');

    expect(response.status).toBe(200);
    expect(response.body.qualityScore).toBeDefined();
    expect(response.body.motivationMetrics).toBeDefined();
  });
});

// Integration: Electron IPC returns motivation data
describe('Electron IPC Integration', () => {
  it('should return motivation verdict for project', async () => {
    const result = await ipcRenderer.invoke('project:getMotivationVerdict', projectId);

    expect(result.ok).toBe(true);
    expect(result.data.verdict).toMatch(/WORTH RESUMING/);
    expect(result.data.effortInvested).toBeDefined();
  });
});
```

### 3. **Unit Tests** (Supplementary)
**Purpose:** Test isolated business logic

**Only write unit tests for:**
- Pure calculation functions
- Complex algorithms
- Edge cases in utilities

**Example:**
```typescript
// Unit: Test motivation verdict calculation logic
describe('calculateMotivationVerdict', () => {
  it('should return "WORTH RESUMING" for high-quality projects', () => {
    const verdict = calculateMotivationVerdict({
      qualityScore: 94,
      sessionCount: 47,
      testsPassing: true,
      docsComplete: true,
      progressPercent: 85,
    });

    expect(verdict).toBe('ABSOLUTELY WORTH RESUMING');
  });

  it('should return "CONSIDER ARCHIVING" for abandoned low-quality projects', () => {
    const verdict = calculateMotivationVerdict({
      qualityScore: 23,
      sessionCount: 2,
      testsPassing: false,
      docsComplete: false,
      progressPercent: 5,
    });

    expect(verdict).toBe('CONSIDER ARCHIVING');
  });
});
```

---

## üîÑ TDD Workflow (RED ‚Üí GREEN ‚Üí REFACTOR)

### Step 1: RED - Write Failing E2E Test First
```typescript
// apps/viewer-app/__tests__/e2e/motivation-dashboard.spec.ts
describe('Motivation Dashboard', () => {
  it('should display "WORTH RESUMING" verdict for high-quality project', async () => {
    // Setup test database with high-quality project
    await seedDatabase({
      project: {
        name: 'cannabis-codex',
        qualityScore: 94,
        sessionCount: 47,
      },
    });

    // Launch app
    const app = await launchElectronApp();

    // Navigate to project
    await app.click('[data-testid="project-cannabis-codex"]');

    // Assert verdict appears
    const verdict = await app.locator('[data-testid="motivation-verdict"]');
    await expect(verdict).toHaveText(/ABSOLUTELY WORTH RESUMING/);
  });
});
```

**Run test:** `npm run test:e2e`
**Expected:** ‚ùå FAIL (feature doesn't exist yet)

### Step 2: RED - Write Failing Integration Test
```typescript
// packages/core-motivation/src/motivation.service.test.ts
describe('MotivationService', () => {
  it('should calculate verdict from project metrics', async () => {
    const mockRepo = {
      getProjectMetrics: async () => ({
        qualityScore: 94,
        sessionCount: 47,
        testsPassing: 247,
        docsScore: 94,
        progressPercent: 85,
      }),
    };

    const service = makeMotivationService({ motivationRepo: mockRepo });
    const verdict = await service.getVerdict('cannabis-codex');

    expect(verdict.decision).toBe('ABSOLUTELY WORTH RESUMING');
    expect(verdict.reasoning).toContain('85% to v1.0');
  });
});
```

**Run test:** `npm run test:integration`
**Expected:** ‚ùå FAIL (service doesn't exist yet)

### Step 3: GREEN - Implement Core Logic
```typescript
// packages/core-motivation/src/motivation.service.ts
export const makeMotivationService = (deps: {
  motivationRepo: ReturnType<typeof makeMotivationRepo>;
}) => ({
  getVerdict: async (projectId: string) => {
    const metrics = await deps.motivationRepo.getProjectMetrics(projectId);

    // Business logic: Calculate verdict
    if (metrics.qualityScore >= 80 && metrics.progressPercent >= 70) {
      return {
        decision: 'ABSOLUTELY WORTH RESUMING',
        reasoning: `You're ${metrics.progressPercent}% to v1.0 release`,
        metrics,
      };
    }

    // ... other conditions
  },
});
```

**Run test:** `npm run test:integration`
**Expected:** ‚úÖ PASS (integration test passes)

### Step 4: GREEN - Wire Adapters
```typescript
// apps/electron-main/src/modules/motivation/motivation.controller.ts
export const makeGetMotivationVerdictIpc =
  (motivationService: ReturnType<typeof makeMotivationService>) =>
  async (_event: IpcMainInvokeEvent, projectId: string) => {
    const verdict = await motivationService.getVerdict(projectId);
    return verdict;
  };

// apps/viewer-app/src/features/MotivationDashboard/MotivationDashboard.tsx
export const MotivationDashboard = ({ projectId }) => {
  const { data: verdict } = useQuery({
    queryKey: ['motivation', projectId],
    queryFn: () => window.electronAPI.getMotivationVerdict(projectId),
  });

  return (
    <div>
      <h2 data-testid="motivation-verdict">{verdict.decision}</h2>
      <p>{verdict.reasoning}</p>
    </div>
  );
};
```

**Run test:** `npm run test:e2e`
**Expected:** ‚úÖ PASS (E2E test passes - feature works end-to-end!)

### Step 5: REFACTOR - Clean Up
- Extract repeated logic
- Improve naming
- Add error handling
- Optimize queries

**All tests still pass after refactoring** ‚úÖ

---

## üß† Brain Garden Integration

### Continuous Validation
PM Agent uses Brain Garden's `brain-monitor` for continuous validation:

```bash
# Start brain monitor (watches for issues)
pnpm brain:watch

# Validate entire codebase
pnpm brain:validate

# View validation errors
pnpm monitor:errors
```

**Brain Monitor checks:**
- ‚úÖ All tests pass before commits
- ‚úÖ No TypeScript errors
- ‚úÖ No ESLint warnings
- ‚úÖ Build succeeds
- ‚úÖ E2E tests pass in CI

### Test Coverage Requirements
- **E2E Tests:** Cover all motivation features
- **Integration Tests:** Cover all Core ‚Üí Database flows
- **Unit Tests:** Cover complex calculations only

**No Coverage % Target** - Focus on testing what matters (features that deliver motivation).

---

## üö® Mandatory Rules

### Rule 1: Test-First for All Features
**Before writing ANY feature code:**
1. Write failing E2E test
2. Write failing integration test
3. Implement Core logic
4. Wire adapters
5. All tests pass

**No exceptions.** This is PM Agent's discipline.

### Rule 2: E2E Tests Prove Motivation Features
Every motivation feature must have an E2E test:
- "Display quality score" ‚Üí E2E test that verifies score appears in UI
- "Calculate motivation verdict" ‚Üí E2E test that verifies verdict appears
- "Show accomplishment feed" ‚Üí E2E test that verifies feed loads

**If there's no E2E test, the feature doesn't exist.**

### Rule 3: Integration Tests Prove Hexagonal Architecture
Every Core service must have integration tests:
- Core service with real repository
- Real database (test fixtures)
- Real file system access (if needed)

**This proves the architecture works.**

### Rule 4: Todo Tracking for Test Work
Use the todo system to track test work:
```typescript
todoManager.createSessionTodo({
  content: 'Write E2E test for motivation dashboard',
  activeForm: 'Writing E2E test for motivation dashboard',
});

// Mark complete with learnings
todoManager.completeSessionTodo(todoId, {
  what: 'E2E test for motivation verdict display',
  how: 'Used Playwright to test Electron app',
  learnings: ['Playwright can test Electron main + renderer together'],
});
```

---

## üéØ PM Agent Test Priorities

### Must Test (E2E + Integration):
1. ‚úÖ Quality score calculation and display
2. ‚úÖ Motivation verdict generation
3. ‚úÖ Project scanning and enrichment
4. ‚úÖ Todo tracking workflows
5. ‚úÖ Screenshot capture and display
6. ‚úÖ Accomplishment feed
7. ‚úÖ Health monitoring

### Should Test (Integration):
8. Database queries (repositories)
9. IPC communication (Electron)
10. API endpoints (Express)

### Can Test (Unit):
11. Complex calculations (if pure functions)
12. Edge cases in utilities

---

## üí° Test Structure

```
apps/viewer-app/
‚îú‚îÄ‚îÄ __tests__/
‚îÇ   ‚îî‚îÄ‚îÄ e2e/
‚îÇ       ‚îú‚îÄ‚îÄ motivation-dashboard.spec.ts
‚îÇ       ‚îú‚îÄ‚îÄ project-viewer.spec.ts
‚îÇ       ‚îî‚îÄ‚îÄ quality-score.spec.ts

packages/core-motivation/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ motivation.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ motivation.service.test.ts    # Integration
‚îÇ   ‚îú‚îÄ‚îÄ motivation.repo.ts
‚îÇ   ‚îî‚îÄ‚îÄ motivation.repo.test.ts        # Integration

packages/core-quality/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ quality.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ quality.service.test.ts        # Integration
‚îÇ   ‚îî‚îÄ‚îÄ calculations.test.ts           # Unit (pure functions)
```

---

## üîó Related Rules

- `monorepo-node-electron-express-hexagonal-architecture.rules.mdc` - TDD workflow for adapters
- `brain-monitor-validation.rules.mdc` - Continuous validation
- `pm-agent-motivation-system.rules.mdc` - Motivation metrics being tested

---

**Remember:** Tests prove features work. Without E2E tests proving motivation metrics display correctly, the PM Agent's core mission fails.

**Test-first. Always.**

---

