# React Component & Application Standards (Bulletproofâ€‘React Enhanced)

> **Purpose**Â Â Unify frontâ€‘end architecture, state, logging, testing, and DX across every app in `/apps/*`, combining our existing guide with proven *Bulletproof React* principles.

---

## 1Â Â Project Layout & Dependency Flow

```text
src/
  app/           # React Router entry (Vite CSR), global providers
  features/      # Selfâ€‘contained domain slices (Auth, Billingâ€¦)
  components/    # Reâ€‘usable UI primitives (Button, Cardâ€¦)
  hooks/         # Shared hooks not tied to a feature
  lib/           # Frameworkâ€‘agnostic utilities (date, mathâ€¦)
  types/         # Global TypeScript contracts
```

* **Unidirectional flow**Â Â `components â†’ features â†’ app` only (enforced via ESLint `import/no-restricted-paths`).
* **Absolute imports**Â Â Configure `@/*` alias in `tsconfig.json` to eliminateÂ `../../../`.

## 2Â Â Code Quality Guardâ€‘Rails

| Tool                                                 | Purpose                  | Invocation                    |
| ---------------------------------------------------- | ------------------------ | ----------------------------- |
| TypeScriptÂ `--strict`                                | Static safety            | `pnpm tsc -p tsconfig.json`   |
| ESLintÂ (+Â plugin\:import, plugin:@typescript-eslint) | Style & dependency rules | `pnpm lint`                   |
| Prettier                                             | Autoâ€‘formatting          | `pnpm format`                 |
| HuskyÂ +Â lintâ€‘staged                                  | Preâ€‘commit gate          | runs `lint`, `format`, `test` |

CI workflow â†’ *fail fast* on lint, type, unit, integration, e2e.

## 3Â Â State Management â€“Â Four Buckets

1. **Local componentÂ state**Â Â Â `useState`, `useReducer`.
2. **UI / appÂ state**Â Â Â Â Â Â Â Â Â Â Context, Zustand, or Redux Toolkit (keep thin slices).
3. **Serverâ€‘cache state**Â Â Â Â Â Â ReactÂ Query (preferred) or SWR.
4. **FormÂ state**Â Â Â Â Â Â Â Â Â Â Â Â Â Â Reactâ€‘Hookâ€‘Form.

> âœ± *Rule:* Never mix bucketsâ€”e.g. donâ€™t put form fields in global UI state.

## 4Â Â API & Data Layer

* All HTTP calls live inÂ `lib/api/` with a single axios instance.
* Generate typed hooks via React Query (`useGetUser`). UI remains declarative.
* Centralised error mapping â†’ userâ€‘friendly toasters, log raw error once.

## 5  UI Component Guidelines

### 5.0 Core Principles

* **Coâ€‘location**Â Â `Button.tsx`, `Button.test.tsx`, `Button.stories.tsx` live together.
* **Props first**Â Â Â Expose minimal surface; favour composition over prop drilling.
* **Styledâ€‘components + Mantine**Â Â Â Â Theme tokens only; ban inline hex colours.

### 5.1 File Naming & Barrel Exports

| Artifact      | Convention               | Example                       |
| ------------- | ------------------------ | ----------------------------- |
| Component     | `PascalCase.tsx`         | `UserCard.tsx`                |
| Styles        | `PascalCase.styles.ts`   | `UserCard.styles.ts`          |
| Tests         | `PascalCase.test.tsx`    | `UserCard.test.tsx`           |
| Stories       | `PascalCase.stories.tsx` | `UserCard.stories.tsx`        |
| Hook          | `useCamelCase.ts`        | `useAuth.ts`                  |
| Folder barrel | `index.ts` reâ€‘export     | `export * from './UserCard';` |

*Rules*

* Prefer **named exports** everywhere; avoids refactor pain and improves treeâ€‘shaking.
* Keep a single React component per file unless trivial variations (e.g., subâ€‘components).
* Never import from a sibling fileâ€™s relative path; use the folder barrel + absolute alias (`@/features/auth`).

### 5.2 Shared Components & Atomic Design

> We blend *Atomic Design* with our **components â†’ features â†’ app** dependency flow by treating the `/components` layer as an atomic toolbox.

```
src/components/
  atoms/        # Lowestâ€‘level primitives â€“ Button, Text, Icon
  molecules/    # Groupings of atoms â€“ AvatarWithName, InputWithLabel
  organisms/    # Complex, reusable blocks â€“ Header, Sidebar, DataTable
  layouts/      # Pageâ€‘level wrappers â€“ DashboardLayout, AuthLayout
```

* **Dependencies**

  * Atoms ğŸš« cannot import molecules or organisms.
  * Molecules may import atoms.
  * Organisms may import atoms and molecules.
  * Layouts may import organisms, molecules, atoms but **never features**.
* **Stories**  Every atom/molecule/organism gets a Storybook story; organisms/layouts also get Playwright interaction tests.
* **Theming**  All atoms rely on Mantineâ€™s theme + styledâ€‘components; higher layers compose without overriding base styles.
* **Promotion rule**  If a featureâ€‘level component is reused twice outside its feature, promote it up the atomic ladder (molecule â†’ organism as complexity grows).

---

## 6  Logging & Observability  (@kit/logger / Pino 8)Â Â Logging & ObservabilityÂ Â (@kit/loggerÂ /Â PinoÂ 8)

### Levels & Usage

| Level           | Useâ€‘case                                           |
| --------------- | -------------------------------------------------- |
| `trace`         | Optâ€‘in request/response body, perf microâ€‘spans     |
| `debug`         | Branch decisions, config dumps                     |
| `info`          | Lifecycles: server start, page mount, route change |
| `warn`          | Recoverable issues, slow queries (>Â 500â€¯ms)        |
| `error / fatal` | Unhandled exceptions, failed externals             |

### Instrumentation Rules

1. Import once per environment:

   ```ts
   // Node
   import { log } from '@kit/logger/node';
   // Browser
   import { log } from '@kit/logger/browser';
   ```
2. **RequestÂ scoping** (Node) â€“ middleware generates `requestId`, attach via `log.child({ requestId })`.
3. **Structured shape** â†’ `{ msg, scope, path, requestId, userId? â€¦ }`.
4. Frontâ€‘end timeline: HTTP calls, feature toggles, critical UI state.
5. Backâ€‘end wrappers: `log.timing('db')` around DB/Redis/S3/Plaid.

```ts
export async function fetchUser(id: string) {
  const logger = log.child({ scope: 'fetchUser', userId: id });
  logger.debug({ id }, 'start');
  const user = await db.getUser(id);
  logger.info({ found: !!user }, 'db lookup complete');
  return user;
}
```

> **Deliverables**Â Â â‰¤â€¯300Â LOC/app, `/kit/logger/examples.ts`, perâ€‘app â€œLogging & Debuggingâ€â€¯README, green CI.

## 7Â Â Error Boundaries & Monitoring

* Wrap every feature entry in `<ErrorBoundary>`; reset on route change.
* Frontâ€‘end: capture to Sentry/Logflare; Backâ€‘end: Pino + CloudWatch.

## 8Â Â Testing Strategy

| Scope              | Tooling                        | Focus                       |
| ------------------ | ------------------------------ | --------------------------- |
| Unit / interaction | Vitest + Reactâ€‘Testingâ€‘Library | Behaviour, not internals    |
| Component visualÂ   | StorybookÂ +Â Ladle tests        | Snapshot & interaction      |
| Integration        | Vitest                         | Module contracts (API â†” UI) |
| E2E                | Playwright                     | Full user flows             |

> **Coverage**Â Â Statement â‰¥Â 80â€¯% critical paths; ignore generated code.

## 9Â Â Performance & DX Defaults

* Codeâ€‘split via `React.lazy` in `app/` routes.
* Memoise expensive selectors/hooks (`useMemo`, `memo`).
* Fast dev start: `pnpm i` â‰¤Â 90â€¯s, `pnpm dev` hot reload â‰¤Â 300â€¯ms.

## 10Â Â Security & Deployment

* `.env`Â managed by `@kit/env-loader`; secrets NEVER commit.
* Enforce HTTPS; helmet in Node.
* GitHub Actions: lint â†’ typeâ€‘check â†’ tests â†’ build â†’ deploy (Netlify/Fly.io).

---

### AppendixÂ Â â€”Â TASKÂ âœÂ **ADD CONSISTENT LOGGING**

*(verbatim task for implementers)*

```
Context
- Monorepo root `/`; all runnable apps in `/apps/*` (Node & React/Mantine)
- Logger: pino 8 via **@kit/logger**
  â€¢ Node  `import { log } from '@kit/logger/node`
  â€¢ Browser `import { log } from '@kit/logger/browser`
- Strict TypeScript (ESM); eslint / prettier; `LOG_LEVEL` default **info**

Goals
1. Instrument key events **once** at the right level
   - **info**  lifecycle (server start, route, page mount)
   - **debug** config, branch decisions
   - **warn**  recoverable issues, slow queries > 500 ms
   - **error / fatal** unhandled exceptions, failed externals
   - **trace** opt-in per request (`X-Debug-Trace: 1`)
2. Structured log shape â†’ `{ msg, scope, path, requestId, userId?, â€¦ }`
3. Front-end: log network timeline, feature toggles, critical UI state; ignore noisy events.
4. Back-end:
   â€¢ requestId middleware â†’ child loggers
   â€¢ log req line + status/duration (body only on **debug**)
   â€¢ wrap DB / Redis / S3 / Plaid with `log.timing()`
5. Self-log progress via `log.child({ scope: 'LoggingMigration' })`

Deliverables
- Source updated with logging (â‰¤ +300 LOC/app)
- `/kit/logger/examples.ts` (best-practice snippets)
- â€œLogging & Debuggingâ€ README section per app
- CI green (lint, vitest, playwright)

Rules
- **Only** @kit/logger (no `console.log`)
- Skip/adjust files already well logged
- Run `pnpm turbo build test` before commit
```

---

**Adopt these standards from the next commit forward.** Ship fast, refactor confidently, *stay bulletproof*.
