---
description: SQLite database patterns and repository design for PM Agent
globs:
  - "packages/core-*/**/*.repo.ts"
  - "packages/core-db/**/*"
  - "db/**/*.sql"
scopes:
  - database
  - sqlite
  - repository
  - pm-agent
alwaysApply: false
---

# PM Agent SQLite Patterns

## üéØ Database Architecture

PM Agent uses **SQLite** as the primary database for:
- **177 tracked projects** across Dev workspace
- **Motivation metrics** (quality scores, effort, features)
- **Session history** (todo tracking, accomplishments)
- **Health monitoring** (build status, test results)

**Location:** `/Users/dmieloch/Dev/.pm-agent/db/pm-agent.db`

**Why SQLite:**
- ‚úÖ Single-file database (easy backup/restore)
- ‚úÖ No server required (embedded)
- ‚úÖ Fast for read-heavy workloads
- ‚úÖ Perfect for desktop Electron apps
- ‚úÖ ACID compliant (data integrity)

---

## üìê Schema Structure (20+ Tables)

### Core Tables

```sql
-- Projects being tracked
CREATE TABLE projects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL UNIQUE,
  path TEXT NOT NULL UNIQUE,
  origin_type TEXT CHECK(origin_type IN ('created', 'forked', 'cloned')),
  ownership TEXT CHECK(ownership IN ('mine', 'customized-fork', 'exploring')),
  lifecycle TEXT CHECK(lifecycle IN ('using', 'building', 'paused', 'reference')),
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_worked_on DATETIME,
  purpose TEXT,
  deployed_url TEXT
);

-- Quality and motivation metrics
CREATE TABLE quality_scores (
  project_id INTEGER PRIMARY KEY,
  quality_score INTEGER CHECK(quality_score BETWEEN 0 AND 100),
  test_coverage INTEGER,
  has_tests BOOLEAN,
  has_ci_cd BOOLEAN,
  has_brain_garden BOOLEAN,
  has_prd BOOLEAN,
  has_architecture_docs BOOLEAN,
  documentation_score INTEGER,
  calculated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- Session tracking
CREATE TABLE claude_sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  project_id INTEGER,
  session_id TEXT UNIQUE,
  started_at DATETIME,
  ended_at DATETIME,
  tokens_used INTEGER,
  goals TEXT,  -- JSON array
  accomplished TEXT,  -- JSON array
  blockers TEXT,  -- JSON array
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);

-- Features tracking
CREATE TABLE features (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  project_id INTEGER,
  feature_name TEXT NOT NULL,
  status TEXT CHECK(status IN ('planned', 'in_progress', 'completed')),
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  completed_at DATETIME,
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);
```

### Key Views

```sql
-- Dashboard view (CI/CD-like health)
CREATE VIEW project_quality_dashboard AS
SELECT
  p.name,
  p.path,
  p.lifecycle,
  q.quality_score,
  q.test_coverage,
  q.has_ci_cd,
  q.has_brain_garden,
  q.documentation_score,
  COUNT(DISTINCT cs.id) as session_count,
  MAX(cs.ended_at) as last_session
FROM projects p
LEFT JOIN quality_scores q ON p.id = q.project_id
LEFT JOIN claude_sessions cs ON p.id = cs.project_id
GROUP BY p.id
ORDER BY q.quality_score DESC;

-- User's original work only
CREATE VIEW my_projects AS
SELECT * FROM projects
WHERE ownership = 'mine' AND origin_type = 'created';

-- Projects by calculated value
CREATE VIEW projects_by_value AS
SELECT
  p.*,
  q.quality_score,
  (
    CASE p.lifecycle
      WHEN 'using' THEN 100
      WHEN 'building' THEN 80
      WHEN 'paused' THEN 40
      ELSE 20
    END +
    COALESCE(q.quality_score, 0) +
    (CASE WHEN q.has_ci_cd THEN 20 ELSE 0 END) +
    (CASE WHEN q.has_brain_garden THEN 20 ELSE 0 END)
  ) AS calculated_value
FROM projects p
LEFT JOIN quality_scores q ON p.id = q.project_id
ORDER BY calculated_value DESC;
```

---

## üèóÔ∏è Repository Pattern (Hexagonal Architecture)

### Repository Structure

```typescript
// packages/core-db/src/db.client.ts
import Database from 'better-sqlite3';

export interface DbClient {
  query<T = any>(sql: string, params?: any[]): T[];
  queryOne<T = any>(sql: string, params?: any[]): T | null;
  execute(sql: string, params?: any[]): { changes: number };
  transaction<T>(fn: () => T): T;
}

export const makeDbClient = (config: { dbPath: string }): DbClient => {
  const db = new Database(config.dbPath);
  db.pragma('journal_mode = WAL');  // Better concurrency
  db.pragma('foreign_keys = ON');   // Enforce FK constraints

  return {
    query: <T = any>(sql: string, params: any[] = []): T[] => {
      return db.prepare(sql).all(...params) as T[];
    },

    queryOne: <T = any>(sql: string, params: any[] = []): T | null => {
      return (db.prepare(sql).get(...params) as T) || null;
    },

    execute: (sql: string, params: any[] = []) => {
      const result = db.prepare(sql).run(...params);
      return { changes: result.changes };
    },

    transaction: <T>(fn: () => T): T => {
      return db.transaction(fn)();
    },
  };
};
```

### Repository Example

```typescript
// packages/core-projects/src/project.repo.ts
import type { DbClient } from '@pkg/core-db';
import type { Project } from './project.types';

export const makeProjectRepo = (deps: { db: DbClient }) => ({
  // Get project by ID
  getById: (id: number): Project | null => {
    return deps.db.queryOne<Project>(
      'SELECT * FROM projects WHERE id = ?',
      [id]
    );
  },

  // Get project by name
  getByName: (name: string): Project | null => {
    return deps.db.queryOne<Project>(
      'SELECT * FROM projects WHERE name = ?',
      [name]
    );
  },

  // List all projects
  list: (): Project[] => {
    return deps.db.query<Project>('SELECT * FROM projects ORDER BY name');
  },

  // Get projects with quality scores (join)
  listWithQuality: () => {
    return deps.db.query<Project & { quality_score: number }>(
      `SELECT p.*, q.quality_score
       FROM projects p
       LEFT JOIN quality_scores q ON p.id = q.project_id
       ORDER BY q.quality_score DESC`
    );
  },

  // Insert new project
  create: (project: Omit<Project, 'id'>): number => {
    const result = deps.db.execute(
      `INSERT INTO projects (name, path, origin_type, ownership, purpose)
       VALUES (?, ?, ?, ?, ?)`,
      [project.name, project.path, project.origin_type, project.ownership, project.purpose]
    );
    return result.lastInsertRowid as number;
  },

  // Update project
  update: (id: number, updates: Partial<Project>): boolean => {
    const fields = Object.keys(updates).map((key) => `${key} = ?`).join(', ');
    const values = Object.values(updates);

    const result = deps.db.execute(
      `UPDATE projects SET ${fields} WHERE id = ?`,
      [...values, id]
    );

    return result.changes > 0;
  },

  // Delete project
  delete: (id: number): boolean => {
    const result = deps.db.execute('DELETE FROM projects WHERE id = ?', [id]);
    return result.changes > 0;
  },
});
```

---

## üîí Best Practices

### 1. Always Use Parameterized Queries
**‚úÖ CORRECT:**
```typescript
deps.db.query('SELECT * FROM projects WHERE name = ?', [projectName]);
```

**‚ùå WRONG (SQL injection risk):**
```typescript
deps.db.query(`SELECT * FROM projects WHERE name = '${projectName}'`);
```

### 2. Use Transactions for Multi-Step Operations
```typescript
export const makeProjectService = (deps: {
  db: DbClient;
  projectRepo: ReturnType<typeof makeProjectRepo>;
}) => ({
  createProjectWithMetrics: (project: Project, quality: QualityMetrics) => {
    return deps.db.transaction(() => {
      const projectId = deps.projectRepo.create(project);
      deps.qualityRepo.create(projectId, quality);
      return projectId;
    });
  },
});
```

### 3. Enforce Foreign Key Constraints
```sql
-- Always use ON DELETE CASCADE for dependent data
CREATE TABLE quality_scores (
  project_id INTEGER PRIMARY KEY,
  -- ...
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);
```

### 4. Use Indexes for Frequently Queried Columns
```sql
-- Index on name for fast lookups
CREATE INDEX idx_projects_name ON projects(name);

-- Index on last_worked_on for sorting
CREATE INDEX idx_projects_last_worked ON projects(last_worked_on DESC);

-- Composite index for common queries
CREATE INDEX idx_projects_ownership_lifecycle
ON projects(ownership, lifecycle);
```

### 5. Store JSON for Flexible Data
```typescript
// Store arrays/objects as JSON text
deps.db.execute(
  'INSERT INTO claude_sessions (goals, accomplished) VALUES (?, ?)',
  [
    JSON.stringify(['Fix Docker', 'Add tests']),
    JSON.stringify(['Fixed Docker networking']),
  ]
);

// Retrieve and parse
const session = deps.db.queryOne<{ goals: string }>(
  'SELECT goals FROM claude_sessions WHERE id = ?',
  [sessionId]
);
const goals = JSON.parse(session.goals);
```

---

## üìä Query Optimization

### Use EXPLAIN QUERY PLAN
```sql
EXPLAIN QUERY PLAN
SELECT * FROM projects
WHERE ownership = 'mine'
ORDER BY last_worked_on DESC;

-- Check if index is used
-- Look for "USING INDEX" in output
```

### Avoid N+1 Queries
**‚ùå WRONG (N+1 problem):**
```typescript
const projects = await projectRepo.list();
for (const project of projects) {
  const quality = await qualityRepo.getByProjectId(project.id);  // N queries!
}
```

**‚úÖ CORRECT (single JOIN):**
```typescript
const projectsWithQuality = deps.db.query(`
  SELECT p.*, q.quality_score
  FROM projects p
  LEFT JOIN quality_scores q ON p.id = q.project_id
`);
```

### Use Prepared Statements for Repeated Queries
```typescript
// In repository, prepare once
const getProjectStmt = db.prepare('SELECT * FROM projects WHERE id = ?');

// Execute many times (cached compilation)
const project1 = getProjectStmt.get(1);
const project2 = getProjectStmt.get(2);
```

---

## üóÑÔ∏è Migration Strategy

### Schema Migrations
```typescript
// db/migrations/001-initial-schema.sql
CREATE TABLE projects (...);
CREATE TABLE quality_scores (...);

// db/migrations/002-add-sessions.sql
CREATE TABLE claude_sessions (...);

// Apply migrations
const migrations = fs.readdirSync('./db/migrations').sort();
for (const migration of migrations) {
  const sql = fs.readFileSync(`./db/migrations/${migration}`, 'utf-8');
  db.exec(sql);
}
```

### Backup Before Migration
```bash
# Backup database
cp .pm-agent/db/pm-agent.db .pm-agent/db/pm-agent.db.backup

# Run migration
node packages/pm-scripts/run-migration.js

# If failed, restore backup
cp .pm-agent/db/pm-agent.db.backup .pm-agent/db/pm-agent.db
```

---

## üß™ Testing with SQLite

### In-Memory Test Database
```typescript
// Use :memory: for fast tests
const testDb = makeDbClient({ dbPath: ':memory:' });

// Seed test data
testDb.execute(`
  INSERT INTO projects (name, path, origin_type)
  VALUES ('test-project', '/test/path', 'created')
`);

// Run tests
const result = await service.getProject('test-project');
expect(result).toBeDefined();
```

### Test Fixtures
```typescript
// Test with real database file (for integration tests)
const fixtureDb = makeDbClient({
  dbPath: './__tests__/fixtures/test-pm-agent.db',
});

beforeEach(() => {
  // Reset database to known state
  fixtureDb.execute('DELETE FROM projects');
  fixtureDb.execute('DELETE FROM quality_scores');

  // Seed fixture data
  seedDatabase(fixtureDb);
});
```

---

## üîó Integration with Hexagonal Architecture

```typescript
// Composition Root (apps/electron-main/src/main.ts)
const dbClient = makeDbClient({ dbPath: './db/pm-agent.db' });

// Repos (dependencies)
const projectRepo = makeProjectRepo({ db: dbClient });
const qualityRepo = makeQualityRepo({ db: dbClient });

// Services (business logic)
const projectService = makeProjectService({ projectRepo, qualityRepo });

// Controllers (adapters)
const projectController = makeProjectController({ projectService });

// Wire to IPC
ipcMain.handle('project:get', projectController.getProjectHandler);
```

---

## üéØ PM Agent Database Priorities

### Must Optimize:
1. ‚úÖ Dashboard queries (project_quality_dashboard view)
2. ‚úÖ Project lookups by name (frequent)
3. ‚úÖ Session history queries (for context loading)

### Should Optimize:
4. Quality score calculations
5. Feature tracking queries
6. Health monitoring queries

### Can Optimize Later:
7. Screenshot metadata queries
8. Cleanup queries (rarely run)

---

## üîó Related Rules

- `monorepo-node-electron-express-hexagonal-architecture.rules.mdc` - Repository pattern
- `pm-agent-tdd-workflow.rules.mdc` - Integration testing with real database
- `pm-agent-domain-logic.rules.mdc` - Domain logic using repositories

---

**Remember:** SQLite is PM Agent's source of truth. All motivation metrics flow through the database. Optimize queries, use indexes, and always test with real data.
