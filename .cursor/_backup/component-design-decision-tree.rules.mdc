---
description: Master decision tree for choosing the right component design pattern when building UI components. Use this to decide between mobile-first, platform pathways, atomic design, and storybook-first approaches.
globs: ['**/*.tsx', '**/*.jsx']
alwaysApply: false
---

# Component Design Decision Tree

## ðŸŽ¯ Purpose
This rule provides a clear decision-making framework for choosing which **frontend UI component** design pattern to apply. It coordinates the following related rules:
- `mobile-first-design.rules.mdc`
- `platform-pathways-pattern.rules.mdc`
- `atomic-design-component-strategy.rules.mdc`
- `storybook-first-composition.rules.mdc`

---

## ðŸ“Š Decision Flow

### Step 1: Is this a third-party component wrapper?

**YES** â†’ Follow **Atomic Design Component Strategy** (`atomic-design-component-strategy.rules.mdc`)
- Wrap Mantine, MUI, or other library components
- Place in `src/ui/atoms/`, `molecules/`, or `organisms/`
- Create Storybook stories

**NO** â†’ Continue to Step 2

---

### Step 2: Is this a new reusable component (not a page)?

**YES** â†’ Follow **Storybook-First Composition** (`storybook-first-composition.rules.mdc`)
- Build component in isolation first
- Create `.stories.tsx` with all variants
- Then integrate into pages

**NO** â†’ Continue to Step 3

---

### Step 3: Does mobile/desktop need significantly different layouts?

**YES** â†’ Follow **Platform Pathways Pattern** (`platform-pathways-pattern.rules.mdc`)

Use this pattern when:
- Component structure differs drastically (e.g., table on desktop vs. cards on mobile)
- Interaction patterns are fundamentally different
- You need separate logic files for each platform

**Structure:**
```
ComponentName.tsx        # Entry point with platform detection
ComponentName.web.tsx    # Desktop implementation
ComponentName.mobile.tsx # Mobile implementation
ComponentName.logic.tsx  # Shared logic (if needed)
ComponentName.styles.ts  # Shared styles
```

**NO** â†’ Follow **Mobile-First Design** (`mobile-first-design.rules.mdc`)

Use this pattern when:
- Same component works on both platforms with responsive CSS
- Only minor layout/styling adjustments needed
- Single component file with media queries suffices

---

## ðŸ”„ Combined Patterns

### Common Combinations:

1. **Atomic + Storybook + Mobile-First**
   - Wrapping a Mantine component
   - Building it in Storybook first
   - Making it responsive with mobile-first CSS

2. **Atomic + Storybook + Platform Pathways**
   - Wrapping a Mantine component
   - Building in Storybook
   - Creating separate mobile/web versions due to major differences

3. **Storybook + Platform Pathways**
   - Custom component (not wrapping third-party)
   - Built in Storybook
   - Needs separate mobile/web implementations

---

## ðŸ“‹ Quick Reference Chart

| Scenario | Patterns to Apply |
|----------|------------------|
| Wrapping Mantine Button | Atomic Design + Storybook + Mobile-First |
| Custom Dashboard Widget (responsive) | Storybook + Mobile-First |
| Data Table (card list on mobile) | Storybook + Platform Pathways |
| Wrapping Mantine Grid (different on mobile) | Atomic Design + Platform Pathways |
| Page-level component | Mobile-First only |
| Complex form (wizard on desktop, paginated on mobile) | Platform Pathways |

---

## âš ï¸ Priority Rules

When patterns conflict, apply in this order:

1. **Atomic Design** (if wrapping third-party)
2. **Storybook-First** (if reusable component)
3. **Platform Pathways** vs **Mobile-First** (based on Step 3)

---

## ðŸ”— Related Rules

- `.cursor/rules/atomic-design-component-strategy.rules.mdc`
- `.cursor/rules/mobile-first-design.rules.mdc`
- `.cursor/rules/platform-pathways-pattern.rules.mdc`
- `.cursor/rules/storybook-first-composition.rules.mdc`

---

## ðŸ’¡ Examples

### Example 1: Wrapping Mantine Button

**Decision Path:**
1. Third-party wrapper? **YES** â†’ Atomic Design
2. Reusable component? **YES** â†’ Storybook-First
3. Different layouts? **NO** â†’ Mobile-First

**Implementation:**
```tsx
// src/ui/atoms/Button/Button.tsx
import { Button as MantineButton } from '@mantine/core';
import styled from 'styled-components';

export const Button = styled(MantineButton)`
  /* Mobile-first styles */
  padding: 12px 16px;
  font-size: 14px;

  @media (min-width: 768px) {
    padding: 14px 24px;
    font-size: 16px;
  }
`;

// src/ui/atoms/Button/Button.stories.tsx
export default { title: 'Atoms/Button', component: Button };
export const Primary = { args: { variant: 'primary' } };
export const Secondary = { args: { variant: 'secondary' } };
```

---

### Example 2: Custom Navigation Bar

**Decision Path:**
1. Third-party wrapper? **NO**
2. Reusable component? **YES** â†’ Storybook-First
3. Different layouts? **YES** â†’ Platform Pathways

**Implementation:**
```tsx
// components/Navigation/Navigation.tsx
import { useMediaQuery } from '@mantine/hooks';
import { NavigationMobile } from './Navigation.mobile';
import { NavigationWeb } from './Navigation.web';

export const Navigation = () => {
  const isMobile = useMediaQuery('(max-width: 768px)');
  return isMobile ? <NavigationMobile /> : <NavigationWeb />;
};

// components/Navigation/Navigation.stories.tsx
export default { title: 'Organisms/Navigation', component: Navigation };
```

---

## ðŸŽ“ Learning Path

**For New Developers:**
1. Start by reading `mobile-first-design.rules.mdc` (always apply baseline)
2. Read `atomic-design-component-strategy.rules.mdc` (for library wrappers)
3. Read `storybook-first-composition.rules.mdc` (for component isolation)
4. Read `platform-pathways-pattern.rules.mdc` (for complex responsive cases)

**For AI Agents:**
Follow this decision tree **before** creating any new frontend component. If uncertain, ask the user which pattern applies.

---

## ðŸ”— Backend Code Organization

**This rule is for FRONTEND components only.**

For backend/Node.js code organization, see:
- **Express APIs**: `monorepo-node-express-architecture.rules.mdc`
- **Scripts/CLIs/Workers**: `node.functional-isolated-concerns.rules.mdc`
- **Decision guide**: `monorepo-structure-and-configuration.rules.mdc`
