---
description: Functional programming pattern for Node.js scripts, CLIs, and standalone programs (NOT Express apps). Enforces isolated concerns, pure functions, and no classes.
globs: ['**/*.ts', '**/*.js']
alwaysApply: false
---

# Rule: Functional Isolated Concerns Architecture

**Use this pattern for:** Scripts, CLIs, background workers, utility packages
**NOT for:** Express.js applications (see `monorepo-node-express-architecture.rules.mdc` instead)

---

## üîó When to Use This Rule

**‚úÖ Use Functional Isolated Concerns when:**
- Building standalone scripts or CLIs
- Creating background workers or batch processors
- Developing utility packages in `/packages/`
- Working on non-HTTP Node.js programs

**‚ùå Use Express Architecture instead when:**
- Building HTTP APIs or web servers
- Need routes, controllers, and middleware
- Working in `/apps/server/` directory
- See: `monorepo-node-express-architecture.rules.mdc`

---

#### 1. **Core Principles**
* **ALWAYS** use functional programming patterns (NO CLASSES)
* **ALWAYS** organize code into isolated concern files
* **COMBINE** both transformations in a single refactoring pass
* **NEVER** create class wrappers or compatibility layers

#### 2. **Refactoring Triggers & Process**
**WHEN** encountering code that violates either principle:
1. **ANALYZE** the entire module/class structure first
2. **TRANSFORM** to functional patterns WHILE splitting into concern files
3. **NEVER** do two-pass refactoring (class‚Üífunctional‚Üíisolated)
4. **DELETE** all class-based code without creating wrappers

#### 3. **Critical Anti-patterns FORBIDDEN**
```typescript
// ‚ùå NEVER create backward compatible class wrappers:
class UserService {
  constructor() {
    this.create = createUser;  // NO!
    this.find = findUser;      // NO!
  }
}

// ‚ùå NEVER create "function bag" objects mimicking classes:
export const userService = {
  create: createUser,  // This is just a class in disguise
  find: findUser
};

// ‚úÖ INSTEAD: Direct function exports
export { createUser, findUser };
```

#### 4. **Single-Pass Transformation Pattern**
**FROM** class-based or monolithic code **TO** functional isolated concerns:

```typescript
// BEFORE: user.ts (class-based monolithic)
class UserService {
  private db: Database;
  
  async createUser(data) { ... }
  async findUser(id) { ... }
  validateEmail(email) { ... }
  hashPassword(password) { ... }
}

// AFTER: user/ folder structure
user/
‚îú‚îÄ‚îÄ user.service.ts        // Pure business logic functions
‚îú‚îÄ‚îÄ user.repository.ts     // Data access functions
‚îú‚îÄ‚îÄ user.validation.ts     // Validation functions
‚îú‚îÄ‚îÄ user.utils.ts          // Utility functions
‚îú‚îÄ‚îÄ user.types.ts          // Type definitions
‚îî‚îÄ‚îÄ index.ts               // Exports
```

#### 5. **Mandatory Refactoring Steps**
**WHEN** refactoring a file named `feature.ts` or class into folder structure:
1. **CREATE** new folder named `feature/`
2. **SPLIT** content into `feature/[name].[purpose].ts` files using functional patterns
3. **CREATE** `feature/index.ts` with exports
4. **UPDATE ALL IMPORTS** in the ENTIRE codebase:
   - Find all files importing from `./feature`, `../feature`, etc.
   - Update imports to point to new structure
   - **ESPECIALLY** update all test files (`.test.ts`, `.spec.ts`)
5. **VERIFY** imports are updated by searching for the old import pattern
6. **DELETE** the original `feature.ts` file
7. **RUN TESTS** to ensure they fail if any imports were missed
8. **VERIFY** no duplicate exports or backward compatibility code exists

**CRITICAL**: Tests MUST be updated BEFORE deleting the original file, otherwise tests will pass with stale imports.

#### 6. **Functional Transformation Rules**
**Classes ‚Üí Functions mapping:**
- Class methods ‚Üí Exported pure functions
- Constructor dependencies ‚Üí Function parameters or closure
- Instance state ‚Üí Function arguments or returned state
- Private methods ‚Üí Non-exported functions in same file
- Static methods ‚Üí Regular exported functions

**State management patterns:**
```typescript
// INSTEAD OF: this.state mutation
// USE: Return new state
const updateUser = (user: User, updates: Partial<User>): User => ({
  ...user,
  ...updates
});

// INSTEAD OF: Dependency injection via constructor
// USE: Higher-order functions or explicit parameters
const createUserService = (db: Database) => ({
  create: (data: UserData) => createUser(db, data),
  find: (id: string) => findUser(db, id)
});
```

#### 7. **File Organization by Concern**
**Standard concern mapping for functional code:**
- `.service.ts` ‚Üí Pure business logic (no I/O)
- `.repository.ts` ‚Üí Data access (I/O isolated here)
- `.controller.ts` ‚Üí HTTP handling (request/response)
- `.validation.ts` ‚Üí Pure validation functions
- `.utils.ts` ‚Üí Pure utility functions
- `.types.ts` ‚Üí TypeScript interfaces/types
- `.effects.ts` ‚Üí Side effects (logging, external APIs)
- `.constants.ts` ‚Üí Constant values
- `.test.ts` or `.spec.ts` ‚Üí Test files

#### 8. **Functional Patterns by Concern Type**

**Services (Pure Business Logic):**
```typescript
// user.service.ts
export const calculateUserScore = (user: User, activities: Activity[]): number =>
  activities.reduce((score, activity) => score + activity.points, user.baseScore);

export const applyDiscount = (price: number, user: User): number =>
  user.isPremium ? price * 0.8 : price;
```

**Repositories (I/O Operations):**
```typescript
// user.repository.ts
export const createUser = async (db: Database, data: UserData): Promise<User> =>
  db.insert('users', data);

export const findUserById = async (db: Database, id: string): Promise<User | null> =>
  db.findOne('users', { id });
```

**Controllers (HTTP Handling):**
```typescript
// user.controller.ts
export const handleCreateUser = (deps: Dependencies) => async (req: Request, res: Response) => {
  const validated = validateUserData(req.body);
  const user = await createUser(deps.db, validated);
  res.json(user);
};
```

#### 9. **Dependency Management**
**INSTEAD OF** class constructor injection:
```typescript
// Option 1: Closure pattern
export const createUserHandlers = (deps: Dependencies) => ({
  create: handleCreateUser(deps),
  find: handleFindUser(deps),
  update: handleUpdateUser(deps)
});

// Option 2: Explicit parameters
export const createUser = async (db: Database, data: UserData): Promise<User> =>
  db.insert('users', data);

// Option 3: Reader monad pattern (advanced)
export const createUser = (data: UserData) => (deps: Dependencies): Promise<User> =>
  deps.db.insert('users', data);
```

#### 10. **Import Rules**
* **Within same feature:** Use relative imports (`./user.types`)
* **Cross-feature:** Use absolute imports from feature root (`@/features/auth/auth.types`)
* **Shared modules:** Use absolute imports (`@/shared/utils/logger`)
* **Circular dependencies:** FORBIDDEN - refactor immediately if detected

#### 11. **Validation Checklist**
Before completing any refactoring:
1. ‚úì No classes exist (except documented exceptions)
2. ‚úì All functions are pure where possible
3. ‚úì Side effects isolated to specific files
4. ‚úì Each file has single concern
5. ‚úì File follows `[name].[purpose].ts` pattern
6. ‚úì Dependencies passed explicitly
7. ‚úì No mutable state (use immutable updates)
8. ‚úì ALL imports updated (search for old import patterns)
9. ‚úì ALL test imports updated specifically
10. ‚úì Original file deleted
11. ‚úì Tests run against NEW structure (not old file)
12. ‚úì No backward compatibility wrappers exist
13. ‚úì No "function bag" objects mimicking classes

#### 12. **Import Update Verification**
```typescript
// REQUIRED verification after refactoring:
verifyNoStaleImports(oldFileName: string) {
  const staleImportPatterns = [
    `from './${oldFileName}'`,
    `from '../${oldFileName}'`,
    `from '../../${oldFileName}'`,
    `import '${oldFileName}'`,
    `require('${oldFileName}')`,
    `require('./${oldFileName}')`
  ];
  
  // Search entire codebase for these patterns
  // If found, refactoring is INCOMPLETE
}
```

#### 13. **Refactoring Decision Tree**
```
FOR each class or monolithic file:
  1. IDENTIFY all methods and their concerns
  2. GROUP methods by concern type
  3. FOR each concern group:
     - CREATE new file with functional exports
     - TRANSFORM class methods to pure functions
     - EXTRACT shared types to .types.ts
  4. UPDATE all imports atomically
  5. DELETE original file
  6. VERIFY tests still pass
```

#### 14. **Subfolder Strategy**
* **Decision tree for component placement:**
  ```txt
  IF component is used by multiple features ‚Üí create in /shared/[component]/
  ELSE IF component is sub-concern of single feature ‚Üí create in /[feature]/[sub-concern]/
  ELSE ‚Üí create as /[feature]/[name].[purpose].ts
  ```
* **Subfolder creation criteria:**
  * Multiple files of same concern type (>3 validators ‚Üí `/validation/` subfolder)
  * Complex sub-features with >5 related files
  * Feature-specific implementations not used elsewhere

#### 15. **Exception Handling**
**Classes are ONLY allowed when:**
1. Framework requires it (with documented reason)
2. Third-party library inheritance (with no functional alternative)
3. Performance-critical stateful operations (with benchmarks proving 20%+ improvement)

**Exception documentation:**
```ts
/**
 * @exception CLASS_BASED_COMPONENT
 * @reason React Native requires class components for ErrorBoundary
 * @functional-alternative none available in framework version 0.72
 * @reevaluate 2025-Q2
 */
```

#### 16. **Anti-patterns to Avoid**
- Creating "function bags" (objects with function properties mimicking classes)
- Backward compatibility class wrappers
- Over-using closures leading to memory leaks
- Mixing concerns in a single function
- Hidden side effects in seemingly pure functions
- Partial refactoring (leaving some methods in classes)
- Default exports (always use named exports)

#### 17. **Performance Optimizations**
**When refactoring, apply these optimizations:**
- Use function composition over method chaining
- Leverage currying for partial application
- Consider memoization for expensive pure functions
- Use lazy evaluation where appropriate
- Prefer `const` functions over `function` declarations

#### 18. **Enforcement**
* **Block operations that:**
  * Create new classes without documented exceptions
  * Create compatibility wrappers
  * Leave original files after refactoring
  * Complete refactoring with stale imports
  * Mix paradigms (functional + class in same module)
* **Auto-fix when possible:**
  * Convert simple classes to functions
  * Update import paths
  * Remove empty compatibility files

---

## 19. Event-Driven Side-Effects (Pub/Sub)

* **Emitter:** Export a singleton `EventEmitter` from `shared/events/eventBus.ts`.
* **Subscribers:**  
  * Drop handlers in either  
    * `modules/<feature>/<feature>.subscriber.ts`, **or**  
    * `subscribers/<domain>.subscriber.ts` (cross-feature).  
  * Handlers register via **import side-effect** in a loader (see ¬ß20).
* **Pattern:** Services emit `eventBus.emit('user.signup', payload)`; subscribers react (`eventBus.on('user.signup', handler)`) to send emails, analytics, etc., without polluting service logic.
* **Testing:** Unit-test subscribers; mock `eventBus` in service tests.

---

## 20. Background Jobs & Scheduling

* **Default runner:** *Agenda.js* (Mongo) or *Bree* (SQL/FS).
* **Folder:** `jobs/<jobName>.job.ts` exporting `{ name, schedule, handler }`.
* **Registration:** `loaders/jobLoader.ts`  
  1. Globs `jobs/**/*.job.ts`  
  2. Registers each job with Agenda/Bree  
  3. Starts the scheduler at bootstrap.
* **Rule of thumb:** Long-running, retryable tasks ‚Üí **jobs**; immediate side-effects ‚Üí **subscribers**.

---

## 21. Loaders Bootstrap Pattern (Express only)

```txt
loaders/
‚îú‚îÄ expressLoader.ts   # sets up app + routes
‚îú‚îÄ dbLoader.ts        # prisma / mongoose connect
‚îú‚îÄ loggerLoader.ts    # pino config
‚îú‚îÄ diLoader.ts        # container bindings
‚îú‚îÄ jobLoader.ts       # ¬ß19
‚îî‚îÄ eventLoader.ts     # wires subscribers

```

`main.ts` awaits each loader in order, passing shared context.  
*`infra/` may still host low-level utilities; ‚Äúloader‚Äù files are purely for bootstrapping.*

---

## 22. Living API Docs

* **Tool:** *Optic* (or *zod-openapi*).  
* **Process:**  
  1. Capture real traffic or convert Zod schemas ‚Üí OpenAPI JSON.  
  2. Commit spec to `docs/openapi.yaml`; CI fails on uncommitted diffs.  
* **Agent hook:** When a controller/schema changes, auto-update the OpenAPI spec.
