---
description: PM Agent domain logic for motivation metrics, quality scoring, and project value calculation
globs:
  - "packages/core-*/src/*.service.ts"
  - "packages/core-*/src/*.logic.ts"
scopes:
  - pm-agent
  - domain
  - motivation
  - business-logic
alwaysApply: false
---

# PM Agent Domain Logic

## üéØ Core Mission

**PM Agent solves the AI development motivation crisis** by making invisible progress visible through data-driven motivation metrics.

**The Problem:**
- AI-assisted development is 10x faster
- Less hands-on time = Less domain recall
- Developers forget project value after short periods
- Memory distortions cause valuable work to be abandoned
- Restart spiral instead of resuming nearly-finished projects

**The Solution:**
PM Agent tracks and calculates motivation metrics that prove project value:
1. üí™ **Effort Invested** - Sessions, tokens, commits, hours
2. üèóÔ∏è **Infrastructure Depth** - Tests, coverage, CI/CD, zero errors
3. ‚ú® **Working Features** - Mapped to user stories, proven by tests
4. üìö **Documentation Quality** - README scores, changelog, docs/
5. üéØ **Progress Tracking** - % complete, proximity to milestones
6. üñºÔ∏è **Visual Memory** - Screenshots to refresh recall

---

## üìê Domain Model

### Core Entities

```typescript
// Project (root aggregate)
interface Project {
  id: number;
  name: string;
  path: string;
  originType: 'created' | 'forked' | 'cloned';
  ownership: 'mine' | 'customized-fork' | 'exploring';
  lifecycle: 'using' | 'building' | 'paused' | 'reference';
  purpose: string;
  lastWorkedOn: Date;
  deployedUrl?: string;
}

// Quality Metrics (value object)
interface QualityMetrics {
  qualityScore: number;  // 0-100
  testCoverage: number;  // 0-100
  hasTests: boolean;
  hasCICD: boolean;
  hasBrainGarden: boolean;
  hasPRD: boolean;
  hasArchitectureDocs: boolean;
  documentationScore: number;  // 0-100
}

// Motivation Verdict (value object)
interface MotivationVerdict {
  decision: 'ABSOLUTELY WORTH RESUMING' | 'WORTH RESUMING' | 'RECONSIDER' | 'CONSIDER ARCHIVING';
  effortInvested: EffortMetrics;
  infrastructureDepth: InfrastructureMetrics;
  workingFeatures: number;
  docsQuality: number;
  progress: ProgressMetrics;
  reasoning: string;
}

// Effort Metrics (value object)
interface EffortMetrics {
  sessionCount: number;
  tokensUsed: number;
  commitCount: number;
  estimatedHours: number;
}

// Progress Metrics (value object)
interface ProgressMetrics {
  percentComplete: number;
  featuresPlanned: number;
  featuresCompleted: number;
  proximity: string;  // "85% to v1.0"
}
```

---

## üí° Business Logic Rules

### 1. Quality Score Calculation

**Algorithm:**
```typescript
// packages/core-quality/src/quality.service.ts
export const makeQualityService = (deps: {
  projectRepo: ReturnType<typeof makeProjectRepo>;
  fsClient: FsClient;
}) => ({
  calculateQualityScore: async (projectPath: string): Promise<number> => {
    const checks = {
      // Testing (40 points max)
      hasTests: await deps.fsClient.exists(`${projectPath}/**/*.test.ts`),
      testCoverage: await getTestCoverage(projectPath),
      hasCICD: await hasCIConfig(projectPath),

      // Documentation (30 points max)
      hasREADME: await deps.fsClient.exists(`${projectPath}/README.md`),
      hasChangelog: await deps.fsClient.exists(`${projectPath}/CHANGELOG.md`),
      hasDocsFolder: await deps.fsClient.exists(`${projectPath}/docs`),
      hasPRD: await deps.fsClient.exists(`${projectPath}/docs/PRD.md`),

      // Architecture (30 points max)
      hasBrainGarden: await deps.fsClient.exists(`${projectPath}/.brain`),
      hasArchDocs: await deps.fsClient.exists(`${projectPath}/ARCHITECTURE.md`),
      hasTooling: await deps.fsClient.exists(`${projectPath}/tooling`),
    };

    // Score calculation
    let score = 0;

    // Testing (40 points)
    if (checks.hasTests) score += 10;
    if (checks.testCoverage >= 80) score += 20;
    else if (checks.testCoverage >= 50) score += 10;
    if (checks.hasCICD) score += 10;

    // Documentation (30 points)
    if (checks.hasREADME) score += 10;
    if (checks.hasChangelog) score += 5;
    if (checks.hasDocsFolder) score += 10;
    if (checks.hasPRD) score += 5;

    // Architecture (30 points)
    if (checks.hasBrainGarden) score += 15;
    if (checks.hasArchDocs) score += 10;
    if (checks.hasTooling) score += 5;

    return Math.min(score, 100);
  },
});
```

**Rules:**
- ‚úÖ Quality score is **0-100**
- ‚úÖ **Testing counts most** (40 points)
- ‚úÖ **Brain Garden integration** is highly valued (15 points)
- ‚úÖ **Documented architecture** proves maintainability (10 points)
- ‚úÖ Score updated on each scan (not cached forever)

### 2. Motivation Verdict Calculation

**Algorithm:**
```typescript
// packages/core-motivation/src/motivation.service.ts
export const makeMotivationService = (deps: {
  motivationRepo: ReturnType<typeof makeMotivationRepo>;
}) => ({
  getVerdict: async (projectId: number): Promise<MotivationVerdict> => {
    const metrics = await deps.motivationRepo.getProjectMetrics(projectId);

    // Calculate verdict based on multiple factors
    const verdictScore = calculateVerdictScore(metrics);

    if (verdictScore >= 80) {
      return {
        decision: 'ABSOLUTELY WORTH RESUMING',
        effortInvested: metrics.effort,
        infrastructureDepth: metrics.infrastructure,
        workingFeatures: metrics.featuresCompleted,
        docsQuality: metrics.docsScore,
        progress: metrics.progress,
        reasoning: `
You invested significant effort (${metrics.effort.sessionCount} sessions, ${metrics.effort.estimatedHours}hrs).
The infrastructure is solid (${metrics.infrastructure.testsPassing}/${metrics.infrastructure.testsTotal} tests passing, ${metrics.infrastructure.coverage}% coverage).
Most features work and are tested.
You're ${metrics.progress.percentComplete}% to v1.0 release.

DON'T START OVER. FINISH THIS.
        `.trim(),
      };
    }

    if (verdictScore >= 60) {
      return {
        decision: 'WORTH RESUMING',
        // ...
        reasoning: `
You've made good progress (${metrics.progress.percentComplete}% complete).
${metrics.effort.sessionCount} sessions invested shows commitment.
Quality could improve (${metrics.quality.qualityScore}/100).

Consider finishing this before starting something new.
        `.trim(),
      };
    }

    if (verdictScore >= 30) {
      return {
        decision: 'RECONSIDER',
        // ...
        reasoning: `
Low quality score (${metrics.quality.qualityScore}/100).
Only ${metrics.progress.percentComplete}% complete.
Consider: Is this still valuable? Or should you archive and start fresh?
        `.trim(),
      };
    }

    return {
      decision: 'CONSIDER ARCHIVING',
      // ...
      reasoning: `
Very low investment (${metrics.effort.sessionCount} sessions).
Poor quality (${metrics.quality.qualityScore}/100).
Minimal progress (${metrics.progress.percentComplete}%).

This might not be worth continuing. Consider archiving.
      `.trim(),
    };
  },
});

// Verdict scoring algorithm
function calculateVerdictScore(metrics: ProjectMetrics): number {
  let score = 0;

  // Quality (30 points)
  score += (metrics.quality.qualityScore / 100) * 30;

  // Effort (20 points)
  if (metrics.effort.sessionCount >= 40) score += 20;
  else if (metrics.effort.sessionCount >= 20) score += 15;
  else if (metrics.effort.sessionCount >= 10) score += 10;
  else if (metrics.effort.sessionCount >= 5) score += 5;

  // Progress (25 points)
  score += (metrics.progress.percentComplete / 100) * 25;

  // Infrastructure (15 points)
  if (metrics.infrastructure.testsPassing === metrics.infrastructure.testsTotal) score += 10;
  if (metrics.infrastructure.coverage >= 80) score += 5;

  // Documentation (10 points)
  score += (metrics.docsScore / 100) * 10;

  return Math.min(score, 100);
}
```

**Rules:**
- ‚úÖ Verdict is data-driven (not subjective)
- ‚úÖ **Quality + Progress matter most** (55 points combined)
- ‚úÖ **Effort prevents false archiving** (don't throw away high-effort projects)
- ‚úÖ Reasoning explains the verdict (not just a score)

### 3. Progress Calculation

**Algorithm:**
```typescript
// packages/core-progress/src/progress.service.ts
export const makeProgressService = (deps: {
  featureRepo: ReturnType<typeof makeFeatureRepo>;
}) => ({
  calculateProgress: async (projectId: number): Promise<ProgressMetrics> => {
    const features = await deps.featureRepo.listByProject(projectId);

    const planned = features.length;
    const completed = features.filter((f) => f.status === 'completed').length;
    const inProgress = features.filter((f) => f.status === 'in_progress').length;

    const percentComplete = planned > 0 ? (completed / planned) * 100 : 0;

    // Proximity calculation
    let proximity = '';
    if (percentComplete >= 85) {
      proximity = `${percentComplete.toFixed(0)}% to v1.0 release - SO CLOSE!`;
    } else if (percentComplete >= 70) {
      proximity = `${percentComplete.toFixed(0)}% to v1.0 release`;
    } else if (percentComplete >= 50) {
      proximity = `${percentComplete.toFixed(0)}% complete`;
    } else {
      proximity = `${completed}/${planned} features complete`;
    }

    return {
      percentComplete: Math.round(percentComplete),
      featuresPlanned: planned,
      featuresCompleted: completed,
      featuresInProgress: inProgress,
      proximity,
    };
  },
});
```

**Rules:**
- ‚úÖ Progress based on **completed features** (not time)
- ‚úÖ **85%+ completion** triggers "SO CLOSE" messaging (motivation!)
- ‚úÖ Features must be tracked (not assumed)

### 4. Effort Tracking

**Algorithm:**
```typescript
// packages/core-effort/src/effort.service.ts
export const makeEffortService = (deps: {
  sessionRepo: ReturnType<typeof makeSessionRepo>;
  gitClient: GitClient;
}) => ({
  calculateEffort: async (projectId: number): Promise<EffortMetrics> => {
    const sessions = await deps.sessionRepo.listByProject(projectId);
    const commits = await deps.gitClient.getCommitCount(projectPath);

    const sessionCount = sessions.length;
    const tokensUsed = sessions.reduce((sum, s) => sum + s.tokensUsed, 0);

    // Estimate hours (rough: 1 session = ~1.5 hours)
    const estimatedHours = Math.round(sessionCount * 1.5);

    return {
      sessionCount,
      tokensUsed,
      commitCount: commits,
      estimatedHours,
    };
  },
});
```

**Rules:**
- ‚úÖ **Session count** is primary effort metric
- ‚úÖ Tokens track AI assistance usage
- ‚úÖ Commits prove tangible progress
- ‚úÖ Hours are estimated (not exact)

---

## üßÆ Calculation Priorities

### Must Calculate Accurately:
1. ‚úÖ **Quality Score** - Drives all other decisions
2. ‚úÖ **Motivation Verdict** - Core feature of PM Agent
3. ‚úÖ **Progress %** - Shows completion proximity

### Should Calculate:
4. Effort metrics (sessions, tokens, hours)
5. Documentation scores
6. Infrastructure depth

### Can Calculate Later:
7. Value score (composite metric)
8. Momentum score (velocity trends)

---

## üîí Domain Rules (Invariants)

### Rule 1: Quality Score is Always 0-100
```typescript
// Enforce invariant
if (qualityScore < 0 || qualityScore > 100) {
  throw new DomainError('Quality score must be between 0 and 100');
}
```

### Rule 2: Projects Must Have Origin Type
```typescript
// Can't create project without origin
if (!project.originType) {
  throw new DomainError('Project must have originType: created, forked, or cloned');
}
```

### Rule 3: Lifecycle Transitions are Restricted
```typescript
// Valid transitions
const VALID_TRANSITIONS = {
  'using': ['paused', 'reference'],
  'building': ['using', 'paused'],
  'paused': ['using', 'building', 'reference'],
  'reference': [],  // Terminal state
};

// Enforce transition rules
if (!VALID_TRANSITIONS[currentLifecycle].includes(newLifecycle)) {
  throw new DomainError(`Cannot transition from ${currentLifecycle} to ${newLifecycle}`);
}
```

### Rule 4: Can't Delete Project with Active Sessions
```typescript
// Business rule
if (await hasActiveSessions(projectId)) {
  throw new DomainError('Cannot delete project with active sessions. Complete or cancel sessions first.');
}
```

---

## üíº Service Composition

```typescript
// Compose services from smaller units
export const makeProjectManagementService = (deps: {
  projectRepo: ReturnType<typeof makeProjectRepo>;
  qualityService: ReturnType<typeof makeQualityService>;
  motivationService: ReturnType<typeof makeMotivationService>;
  progressService: ReturnType<typeof makeProgressService>;
  effortService: ReturnType<typeof makeEffortService>;
}) => ({
  getProjectWithMotivation: async (projectId: number) => {
    const project = await deps.projectRepo.getById(projectId);
    if (!project) throw new NotFoundError('Project not found');

    // Compose from multiple services
    const [quality, verdict, progress, effort] = await Promise.all([
      deps.qualityService.getQualityMetrics(projectId),
      deps.motivationService.getVerdict(projectId),
      deps.progressService.calculateProgress(projectId),
      deps.effortService.calculateEffort(projectId),
    ]);

    return {
      project,
      quality,
      verdict,
      progress,
      effort,
    };
  },
});
```

---

## üß™ Testing Domain Logic

### Unit Test Pure Calculations
```typescript
describe('calculateVerdictScore', () => {
  it('should return 100 for perfect project', () => {
    const score = calculateVerdictScore({
      quality: { qualityScore: 100 },
      effort: { sessionCount: 50 },
      progress: { percentComplete: 100 },
      infrastructure: { testsPassing: 247, testsTotal: 247, coverage: 95 },
      docsScore: 100,
    });

    expect(score).toBe(100);
  });

  it('should return low score for minimal project', () => {
    const score = calculateVerdictScore({
      quality: { qualityScore: 20 },
      effort: { sessionCount: 2 },
      progress: { percentComplete: 10 },
      infrastructure: { testsPassing: 0, testsTotal: 0, coverage: 0 },
      docsScore: 10,
    });

    expect(score).toBeLessThan(30);
  });
});
```

### Integration Test Full Service
```typescript
describe('MotivationService Integration', () => {
  it('should calculate correct verdict for high-quality project', async () => {
    // Setup: Real database with test data
    const projectId = await seedProject({
      qualityScore: 94,
      sessionCount: 47,
      featuresCompleted: 12,
      featuresPlanned: 15,
    });

    const service = makeMotivationService({ motivationRepo });
    const verdict = await service.getVerdict(projectId);

    expect(verdict.decision).toBe('ABSOLUTELY WORTH RESUMING');
    expect(verdict.reasoning).toContain('85% to v1.0');
  });
});
```

---

## üéØ PM Agent Domain Priorities

### Must Implement Correctly:
1. ‚úÖ Quality score calculation
2. ‚úÖ Motivation verdict generation
3. ‚úÖ Progress tracking
4. ‚úÖ Lifecycle transitions

### Should Implement:
5. Effort tracking
6. Documentation scoring
7. Infrastructure metrics

### Can Implement Later:
8. Value prediction
9. Momentum trending
10. AI-powered recommendations

---

## üîó Related Rules

- `monorepo-node-electron-express-hexagonal-architecture.rules.mdc` - Service layer patterns
- `pm-agent-sqlite-patterns.rules.mdc` - Repository patterns for data access
- `pm-agent-tdd-workflow.rules.mdc` - Testing domain logic
- `pm-agent-motivation-system.rules.mdc` - Motivation philosophy

---

**Remember:** Domain logic is pure business rules. Keep it framework-agnostic (no Electron, Express, React). Test it thoroughly with unit tests.

**The PM Agent's mission lives in this domain layer.**
